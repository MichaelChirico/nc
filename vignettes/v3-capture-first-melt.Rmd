<!--
%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{vignette 3: capture first melt}
-->

# Capture first melt

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This vignette explains how to use functions for "melting" wide
data tables, i.e. converting to tall data tables:

* `nc::capture_first_melt` is useful when you have a wide data table
  with lots of columns, all of the same type, that you would like to
  melt into a single result/output column.
* `nc::capture_first_melt_multiple` is useful when you have a wide
  data table with columns of different types that you would like to
  melt into multiple result/output columns.

## Capture data.frame column names and melt matching columns

Sometimes you want to melt a "wide" data table which has several
distinct pieces of information encoded in each column name. One
example is the familiar iris data, which have flower part and
measurement dimension encoded in each of four column names:

```{r}
library(data.table)
iris.dt <- data.table(i=1:nrow(iris), iris[,1:4], Species=paste(iris$Species))
(iris.tall <- nc::capture_first_melt(
  iris.dt,
  part=".*",
  "[.]",
  dim=".*"))
```

After the data have been converted to the tall table above, we can do a
`dcast` to get a data table which can help us visualize whether or not
sepals are bigger than petals:

```{r, fig.width=10}
(iris.part.cols <- dcast(
  iris.tall,
  i + Species + dim ~ part))
library(ggplot2)
ggplot()+
  theme_bw()+
  theme(panel.spacing=grid::unit(0, "lines"))+
  facet_grid(dim ~ Species)+
  coord_equal()+
  geom_abline(slope=1, intercept=0, color="grey")+
  geom_point(aes(
    Petal, Sepal),
    data=iris.part.cols)
```

It is clear from the plot above that sepals are indeed both longer and
wider than petals, on each measured plant.

Another data set where it is useful to do column name pattern matching
followed by melting is the World Health Organization data:

```{r}
data(who, package="tidyr")
names(who)
```

Each column which starts with `new` has three distinct pieces of
information encoded in its name: diagnosis type (e.g. sp or rel),
gender (m or f), and age range (e.g. 5564 or 1524). We would like to
use a regex to match these column names, then using the matching
columns as measure.vars in a melt, then join the two results. We
therefore provide the `nc::capture_first_melt` function which wraps
`nc::capture_first_vec` and `melt`:

```{r}
nc::capture_first_melt(
  who,
  "new_?",
  diagnosis=".*",
  "_",
  gender=".",
  ages=".*")
```

Note the result includes additional columns `variable` and `value`
from `melt`. The `variable` column contains the input column
names which matched the specified pattern, and there is a new column
for each group in that pattern. The following example shows how to
rename the `variable` and `value` columns, and use numeric type
conversion functions:

```{r}
years.pattern <- list(
  "new_?",
  diagnosis=".*",
  "_",
  gender=".",
  ages=list(
    min.years="0|[0-9]{2}", as.numeric,
    max.years=list("[0-9]{2}"), "?",
    function(x)ifelse(x=="", Inf, as.numeric(x))))
who.typed <- nc::capture_first_melt(
  who, years.pattern,
  value.name="count",
  variable.name="column")
str(who.typed)
```

The result above shows that non-character result columns can be
obtained by specifying type conversion functions.

## Comparison with tidyr

The `nc::capture_first_melt` function was inspired by the `tidyr`
package, which can accomplish the same computation via:

```{r}
tidyr::pivot_longer(
  who, new_sp_m014:newrel_f65,
  names_to=c("diagnosis", "gender", "ages"),
  names_pattern="new_?(.*)_(.)(.*)")
```

The syntax above is somewhat repetitive, since it requires specifying
columns to melt as the second argument, and it also requires
`names_pattern` which could be used to identify the columns to melt,
e.g.

```{r}
names.pattern <- "new_?(.*)_(.)(.*)"
tidyr::pivot_longer(
  who, grep(names.pattern, names(who)),
  names_to=c("diagnosis", "gender", "ages"),
  names_pattern=names.pattern)
```

To accomplish the type conversion using tidyr we need to do a
post-processing step, which requires additional repetition of the
column names we want to convert:

```{r}
(years.pattern.str <- nc::var_args_list(years.pattern)$pattern)
tidyr.typed <- transform(tidyr::pivot_longer(
  who,
  grep(years.pattern.str, names(who)),
  names_to=c("diagnosis", "gender", "ages", "min.years.str", "max.years.str"),
  names_pattern=years.pattern.str),
  min.years=as.numeric(min.years.str),
  max.years=ifelse(is.na(max.years.str), Inf, as.numeric(max.years.str)))
str(tidyr.typed)
```

In conclusion `nc::capture_first_melt` provides an alternative which
(1) makes it easier to define complex patterns (2) supports type
conversion without a post-processing step, and (3) reduces repetition
in user code.

## Melting columns of different types into multiple result columns

In the previous sections we discussed methods for melting wide data
columns that all have the same type. Sometimes wide data have columns
of different types that we want to melt. The example below is taken
from a data.table vignette,

```{r}
family.dt <- fread(text="
family_id age_mother dob_child1 dob_child2 dob_child3 gender_child1 gender_child2 gender_child3
1         30 1998-11-26 2000-01-29         NA             1             2            NA
2         27 1996-06-22         NA         NA             2            NA            NA
3         26 2002-07-11 2004-04-05 2007-09-02             2             2             1
4         32 2004-10-10 2009-08-27 2012-07-21             1             1             1
5         29 2000-12-05 2005-02-28         NA             2             1            NA")
```

The data table above has one row for each family, and two columns for
each child. One column is the date of birth (character), the other is
the gender (coded as an integer). We can use standard data.table
functions to melt these data into a tall table with one row for each
child:

```{r}
melt(family.dt, variable.name="child", measure.vars=patterns(
  dob="^dob", gender="^gender"
))
```

The melt above results in a table with one row for each child, and one
column for each argument of `patterns`. However the code is somewhat
repetitive, as `dob` and `gender` must be repeated. To avoid this
repetition we can instead use:

```{r}
nc::capture_first_melt_multiple(
  family.dt,
  column=".*",
  "_",
  nc::field("child", "", "[1-3]"))
```

The result above is similar to the previous result (and in fact
`melt.data.table` is used internally), but the code is less
repetitive. The first argument of `capture_first_melt_multiple` is the
subject data table and the following arguments form a pattern which is
matched to the input data column names. The pattern must have at least
two groups:

* One group must be named `column`. This group is used to capture the
  part of the input column names which will be used for the output
  column names. The output will contain one column for each unique
  value captured in this group.
* One or more other groups (with any names) specify an identifier for
  each observation (above it was the `child` number).

Another example is the iris data set which usually has one
5-dimensional observation per row (four numeric measures, and one
character `Species`). Below we create a shuffled version of the iris
data with two observations per row:

```{r}
set.seed(1)
iris.rand <- iris.dt[sample(.N)]
iris.wide <- cbind(treatment=iris.rand[1:75], control=iris.rand[76:150])
print(iris.wide, topn=2, nrows=10)
```

Below we show the usual data.table syntax for getting the original
iris back.

```{r}
iris.melted <- melt(iris.wide, measure.vars = patterns(
  i="i$",
  Sepal.Length="Sepal.Length$",
  Sepal.Width="Sepal.Width$",
  Petal.Length="Petal.Length$",
  Petal.Width="Petal.Width$",
  Species="Species$"))
identical(iris.melted[order(i), names(iris.dt), with=FALSE], iris.dt)
```

We can do the same thing with less repetition via:

```{r}
(nc.melted <- nc::capture_first_melt_multiple(
  iris.wide,
  group=".*?",
  "[.]",
  column=".*"))
identical(nc.melted[order(i), names(iris.dt), with=FALSE], iris.dt)
```
