<!--
%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{vignette 4: comparisons with other packages}
-->

# Comparisons with other packages

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This vignette provides comparisons with other packages that provide
similar functionality. We begin
by defining a helper function which ensures that results are the same:

```{r}
compare <- function(..., exclude="variable"){
  mc <- match.call()
  default.names <- paste(lapply(mc[-1], "[[", 1))
  L <- list(...)
  to.rep <- if(is.null(names(L)))rep(TRUE, length(L)) else names(L)==""
  names(L)[to.rep] <- default.names[to.rep]
  sorted.list <- list()
  all.name.vec <- names(L[[1]])
  name.vec <- all.name.vec[!all.name.vec %in% exclude]
  for(fun.name in names(L)){
    result <- data.table(L[[fun.name]])
    if(!all(name.vec %in% names(result))){
      print(result)
      stop("result needs names: ", paste(name.vec, collapse=", "))
    }
    sorted <- result[, name.vec, with=FALSE]
    setkeyv(sorted, name.vec)
    sorted.list[[fun.name]] <- sorted
  }
  ref.dt <- sorted.list[[1]]
  others <- sorted.list[-1]
  for(fun.name in names(others)){
    other.dt <- others[[fun.name]]
    all.eq <- all.equal(other.dt, ref.dt)
    if(!isTRUE(all.eq)){
      cat(fun.name, "\n", all.eq, "\n\n", sep="")
    }
  }
  L
}
```

Note that the function above returns a list of data frames, and checks
that each element in the list is equal to the first element.

## Are sepals larger or smaller than petals in the iris data?

Sometimes you want to melt a "wide" data table which has several
distinct pieces of information encoded in each column name. One
example is the familiar iris data, which have flower part and
measurement dimension encoded in each of four column names:

```{r}
library(data.table)
data.table(iris)
```

The goal in this section will be to convert these data into a format
with a column for each flower part (`Sepal` and `Petal`) so we can
easily make a facetted scatterplot to visually examine whether or not
sepals or larger than petals. The easiest way to perform this
conversion is with packages which provide a function for melting into
multiple output columns:

```{r}
iris.parts <- compare(
  nc::capture_first_melt_multiple(
    iris,
    column=".*?",
    "[.]",
    dim=".*"),
  tidyr::pivot_longer(
    iris, 
    cols=1:4, 
    names_to=c(".value", "dim"),
    names_sep="[.]"),
  stats::reshape(
    iris,
    direction="long",
    timevar="dim",
    varying=1:4,
    sep="."),
  "data.table::melt"=melt(
    data.table(iris),
    measure.vars=patterns(
      Sepal="^Sepal",
      Petal="^Petal")
  )[data.table(
    variable=factor(1:2), dim=c("Length", "Width")
  ), on=.(variable)],
  cdata::rowrecs_to_blocks(
    iris,
    controlTable=data.frame(
      dim=c("Length", "Width"),
      Petal=c("Petal.Length", "Petal.Width"),
      Sepal=c("Sepal.Length", "Sepal.Width"),
      stringsAsFactors=FALSE),
    columnsToCopy="Species"))
iris.parts$nc
```

It is clear from the code above that each package is capable of
the conversions. However the syntax and level of explicitness varies:

* `nc::capture_first_melt_multiple` requires a regular
  expression: (most implicit, least repetition)
  * any input column names that match the regex are melted.
  * values matched in the `column` group are used for the output column names.
* `tidyr::pivot_longer` and `stats::reshape` require specification of
  the input columns to melt along with a separator.
  * `stats::reshape` assumes the output columns names occur in the
    part of the input column name before the separator.
  * `tidyr::pivot_longer` assumes the output columns occur in the part
    which corresponds to the `.value` element of the `names_to`
    argument.
* `data.table::melt` requires a join to recover the `dim` output
  column.
* `cdata::rowrecs_to_blocks` requires explicit specification of a
  control table. (most explicit, most repetition)

Any of the results can be visualized via:

```{r}
library(ggplot2)
ggplot()+
  theme_bw()+
  theme(panel.spacing=grid::unit(0, "lines"))+
  facet_grid(dim ~ Species)+
  coord_equal()+
  geom_abline(slope=1, intercept=0, color="grey")+
  geom_point(aes(
    Petal, Sepal),
    data=iris.parts$nc)
```

It is clear from the plot above that sepals are larger than petals,
for every measured flower. 

## Comparing dimensions in iris data

What if we wanted to compare dimensions rather than parts? 

```{r}
iris.dims <- compare(
  nc::capture_first_melt_multiple(
    iris,
    part=".*?",
    "[.]",
    column=".*"),
  tidyr::pivot_longer(
    iris, 
    cols=1:4, 
    names_to=c("part", ".value"),
    names_sep="[.]"),
  stats::reshape(
    structure(iris, names=sub("(.*?)[.](.*)", "\\2.\\1", names(iris))),
    direction="long",
    timevar="part",
    varying=1:4,
    sep="."),
  "data.table::melt"=melt(
    data.table(iris),
    measure.vars=patterns(
      Length="Length$",
      Width="Width$")
  )[data.table(
    variable=factor(1:2), part=c("Sepal", "Petal")
  ), on=.(variable)],
  cdata::rowrecs_to_blocks(
    iris,
    controlTable=data.frame(
      part=c("Petal", "Sepal"),
      Length=c("Petal.Length", "Sepal.Length"),
      Width=c("Petal.Width", "Sepal.Width"),
      stringsAsFactors=FALSE),
    columnsToCopy="Species"))
iris.dims$nc
```

The code above shows that the syntax is mostly the same for this
example. The biggest difference is for `stats::reshape` which assumes
that each input column name is composed of (1) the output column name,
(2) a delimiter, and (3) some additional information to be stored in
the output column given by `timevar`. Therefore we need to pre-process
column names using `sub` for it to work.

```{r}
ggplot()+
  theme_bw()+
  theme(panel.spacing=grid::unit(0, "lines"))+
  facet_grid(part ~ Species)+
  coord_equal()+
  geom_abline(slope=1, intercept=0, color="grey")+
  geom_point(aes(
    Length, Width),
    data=iris.dims$data)
```

It is clear from the plot above that `Length` is larger than `Width`
for every measured flower part. This conversion is also
straightforward with these other packages:

## Melting into a single output column, character types

Another data set where it is useful to do column name pattern matching
followed by melting is the World Health Organization data:

```{r}
data(who, package="tidyr")
names(who)
```

Each column which starts with `new` has three distinct pieces of
information encoded in its name: diagnosis type (e.g. sp or rel),
gender (m or f), and age range (e.g. 5564 or 1524). We would like to
use a regex to match these column names, then using the matching
columns as measure.vars in a melt, then join the two results. The most
convenient way to do that is via:

```{r}
compare(
  nc::capture_first_melt(
    who,
    "new_?",
    diagnosis=".*",
    "_",
    gender=".",
    ages=".*"),
  tidyr::pivot_longer(
    who, new_sp_m014:newrel_f65,
    names_to=c("diagnosis", "gender", "ages"),
    names_pattern="new_?(.*)_(.)(.*)"))
```

Note the result includes additional columns `variable` and `value`
from `melt`. The `variable` column contains the input column names
which matched the specified pattern, and there is a new column for
each group in that pattern. The following example shows how to rename
the `variable` and `value` columns, specify `id.vars`, remove missing
values with `na.rm`, and use numeric type conversion functions:

```{r}
library(dplyr)
who.typed <- compare(
  nc::capture_first_melt(
    who,
    "new_?",
    diagnosis=".*",
    "_",
    gender=".",
    ages=list(
      ymin.num="0|[0-9]{2}", as.numeric,
      ymax.num="[0-9]{0,2}", function(y)ifelse(y=="", Inf, as.numeric(y))),
    value.name="count",
    na.rm=TRUE),
  tidyr::pivot_longer(
    who, new_sp_m014:newrel_f65,
    names_to=c("diagnosis", "gender", "ages", "ymin.chr", "ymax.chr"),
    names_pattern="new_?(.*)_(.)((0|[0-9]{2})([0-9]{0,2}))",
    values_drop_na=TRUE,
    values_to="count"
   ) %>% mutate(
    ymin.num=as.numeric(ymin.chr),
    ymax.num=ifelse(ymax.chr=="", Inf, as.numeric(ymax.chr))))
str(who.typed)  
```

The result above shows that `nc::capture_first_melt` (1) makes it
easier to define complex patterns (2) supports type conversion without
a post-processing step, and (3) reduces repetition in user code.

## Melting columns of different types into multiple result columns

In the previous sections we discussed methods for melting wide data
columns that all have the same type. Sometimes wide data have columns
of different types that we want to melt. The example below is taken
from a data.table vignette,

```{r}
family.dt <- fread(text="
family_id age_mother dob_child1 dob_child2 dob_child3 gender_child1 gender_child2 gender_child3
1         30 1998-11-26 2000-01-29         NA             1             2            NA
2         27 1996-06-22         NA         NA             2            NA            NA
3         26 2002-07-11 2004-04-05 2007-09-02             2             2             1
4         32 2004-10-10 2009-08-27 2012-07-21             1             1             1
5         29 2000-12-05 2005-02-28         NA             2             1            NA")
```

The data table above has one row for each family, and two columns for
each child. One column is the date of birth (character), the other is
the gender (coded as an integer). We can use standard data.table
functions to melt these data into a tall table with one row for each
child:

```{r}
melt(family.dt, variable.name="child", measure.vars=patterns(
  dob="^dob", gender="^gender"
))
```

The melt above results in a table with one row for each child, and one
column for each argument of `patterns`. However the code is somewhat
repetitive, as `dob` and `gender` must be repeated. To avoid this
repetition we can instead use:

```{r}
(children.dt <- nc::capture_first_melt_multiple(
  family.dt,
  column=".*",
  "_",
  nc::field("child", "", "[1-3]", as.integer),
  na.rm=TRUE))
str(children.dt)
```

The result above is similar to the previous result (and in fact
`melt.data.table` is used internally), but the code is less
repetitive. The first argument of `capture_first_melt_multiple` is the
subject data table and the following arguments form a pattern which is
matched to the input data column names. The pattern must have at least
two groups:

* One group must be named `column`. This group is used to capture the
  part of the input column names which will be used for the output
  column names. The output will contain one column for each unique
  value captured in this group.
* One or more other groups (with any names) specify an identifier for
  each observation (above it was the `child` number).

Another example is the iris data set which usually has one
5-dimensional observation per row (four numeric measures, and one
character `Species`). Below we create a shuffled version of the iris
data with two observations per row:

```{r}
set.seed(1)
iris.rand <- iris.dt[sample(.N)]
iris.wide <- cbind(treatment=iris.rand[1:75], control=iris.rand[76:150])
print(iris.wide, topn=2, nrows=10)
```

Below we show the usual data.table syntax for getting the original
iris back.

```{r}
iris.melted <- melt(iris.wide, measure.vars = patterns(
  i="i$",
  Sepal.Length="Sepal.Length$",
  Sepal.Width="Sepal.Width$",
  Petal.Length="Petal.Length$",
  Petal.Width="Petal.Width$",
  Species="Species$"))
identical(iris.melted[order(i), names(iris.dt), with=FALSE], iris.dt)
```

We can do the same thing with less repetition via:

```{r}
(nc.melted <- nc::capture_first_melt_multiple(
  iris.wide,
  group=".*?",
  "[.]",
  column=".*"))
identical(nc.melted[order(i), names(iris.dt), with=FALSE], iris.dt)
```

To conclude this section, we have seen that a simple non-repetitive
regex syntax can be used with `nc::capture_first_melt_multiple` to
melt wide data into several columns of different types.

## Comparison with tidyr syntax

The syntax below can be used to get the tall data table of children:

```{r}
tidyr::pivot_longer(
  family.dt,
  cols=dob_child1:gender_child3,
  names_pattern="(.*)_child([1-3])",
  names_to=c(".value", "child.str"),
  values_drop_na=TRUE)
```

However the code is somewhat repetitive, as the columns to melt must
be specified in two arguments: `cols` and `names_pattern`. A
workaround is to use a pre-defined pattern for both arguments:

```{r}
child.pat.str <- "(.*)_child([1-3])"
tidyr.children <- tidyr::pivot_longer(
  family.dt,
  cols=grep(child.pat.str, names(family.dt)),
  names_pattern=child.pat.str,
  names_to=c(".value", "child.str"),
  values_drop_na=TRUE)
(tidyr.converted <- transform(
  tidyr.children,
  child=as.integer(child.str)))
str(tidyr.converted)
```

However there is still some repetition: `child` appears in both the
pattern string and the `names_to` argument. That repetition is avoided
if `nc::capture_first_melt_multiple` is used with `nc::field`.

Another difference is that `nc` allows specification of type
conversion functions in the pattern, which results in an integer
`child` column. In contrast with `tidyr` output columns such as
`child.str` which are created using a regex capture group are always
character, so type conversions must be specified as a post-processing
step.

To conclude this section, we have seen that `tidyr::pivot_longer` uses
a different syntax to perform a similar computation to
`nc::capture_first_melt_multiple`. Two differences are that `nc`
syntax is less repetitive, and allows specifying type conversion
functions in the pattern, which avoids the need for a post-processing
step.
