<!--
%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{vignette 4: comparisons with other packages}
-->

# Comparisons with other packages

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This vignette provides comparisons with other packages that provide
similar functionality. We begin
by defining a helper function which ensures that results are the same:

```{r}
compare <- function(...){
  mc <- match.call()
  default.names <- paste(lapply(mc[-1], "[[", 1))
  L <- list(...)
  to.rep <- names(L)==""
  names(L)[to.rep] <- default.names[to.rep]
  sorted.list <- list()
  name.vec <- names(L[[1]])
  for(fun.name in names(L)){
    result <- data.table(L[[fun.name]])
    sorted <- result[, name.vec, with=FALSE]
    setkeyv(sorted, name.vec)
    sorted.list[[fun.name]] <- sorted
  }
  ref.dt <- sorted.list[[1]]
  others <- sorted.list[-1]
  for(fun.name in names(others)){
    other.dt <- others[[fun.name]]
    all.eq <- all.equal(other.dt, ref.dt)
    if(!isTRUE(all.eq)){
      browser()
      cat(fun.name, "\n", all.eq, "\n\n", sep="")
    }
  }
  L
}
```

## Are sepals larger or smaller than petals in the iris data?

Sometimes you want to melt a "wide" data table which has several
distinct pieces of information encoded in each column name. One
example is the familiar iris data, which have flower part and
measurement dimension encoded in each of four column names:

```{r}
library(data.table)
data.table(iris)
```

The goal in this section will be to convert these data into a format
with a column for each flower part (`Sepal` and `Petal`) so we can
easily make a facetted scatterplot to visually examine whether or not
sepals or larger than petals.

### Melting into multiple output columns: nc

The easiest way to perform this conversion is with packages which
provide a function for melting into multiple output columns.

```{r}
iris.parts <- compare(
  nc::capture_first_melt_multiple(
    iris,
    column=".*?",
    "[.]",
    dim=".*"),
  tidyr::pivot_longer(
    iris, 
    cols=1:4, 
    names_to=c(".value", "dim"),
    names_sep="[.]"),
  stats::reshape(
    iris,
    direction="long",
    timevar="dim",
    varying=1:4,
    sep="."),
  "data.table::melt"=melt(
    data.table(iris),
    measure.vars=patterns(
      Sepal="^Sepal",
      Petal="^Petal")
  )[data.table(
    variable=factor(1:2), dim=c("Length", "Width")
  ), on=.(variable)],
  cdata::rowrecs_to_blocks(
    iris,
    controlTable=data.frame(
      dim=c("Length", "Width"),
      Petal=c("Petal.Length", "Petal.Width"),
      Sepal=c("Sepal.Length", "Sepal.Width"),
      stringsAsFactors=FALSE),
    columnsToCopy="Species"))
```

It is clear from the code above that each package is capable of
the conversions. However the syntax and level of explicitness varies:

* `nc::capture_first_melt_multiple` requires a regular
  expression: (most implicit, least repetition)
  * any input column names that match the regex are melted.
  * values matched in the `column` group are used for the output column names.
* `tidyr::pivot_longer` and `stats::reshape` require specification of
  the input columns to melt along with a separator.
  * `stats::reshape` assumes the output columns names occur in the
    part of the input column name before the separator.
  * `tidyr::pivot_longer` assumes the output columns occur in the part
    which corresponds to the `.value` element of the `names_to`
    argument.
* `data.table::melt` requires a join to recover the `dim` output
  column.
* `cdata::rowrecs_to_blocks` requires explicit specification of a
  control table. (most explicit, most repetition)

Any of the results can be visualized via:

```{r}
library(ggplot2)
ggplot()+
  theme_bw()+
  theme(panel.spacing=grid::unit(0, "lines"))+
  facet_grid(dim ~ Species)+
  coord_equal()+
  geom_abline(slope=1, intercept=0, color="grey")+
  geom_point(aes(
    Petal, Sepal),
    data=iris.parts$nc)
```

It is clear from the plot above that sepals are larger than petals,
for every measured flower. 


## Comparing dimensions

What if we wanted to compare dimensions rather than parts? 

```{r}
(iris.dt <- data.table(iris[,1:4], Species=paste(iris$Species), i=1:nrow(iris)))
iris.dims <- compare(
  nc::capture_first_melt_multiple(
    iris.dt,
    part=".*?",
    "[.]",
    column=".*"),
  tidyr::pivot_longer(
    iris.dt, 
    cols=1:4, 
    names_to=c("part", ".value"),
    names_sep="[.]"),
  stats::reshape(
    structure(iris.dt, names=sub("(.*?)[.](.*)", "\\2.\\1", names(iris.dt))),
    direction="long",
    timevar="part",
    varying=1:4,
    sep="."),
  "data.table::melt"=melt(
    data.table(iris.dt),
    measure.vars=patterns(
      Length="Length$",
      Width="Width$")
  )[data.table(
    variable=factor(1:2), part=c("Sepal", "Petal")
  ), on=.(variable)],
  cdata::rowrecs_to_blocks(
    iris.dt,
    controlTable=data.frame(
      part=c("Petal", "Sepal"),
      Length=c("Petal.Length", "Sepal.Length"),
      Width=c("Petal.Width", "Sepal.Width"),
      stringsAsFactors=FALSE),
    columnsToCopy=c("i", "Species")))

```

It is clear from the plot above that `Length` is larger than `Width`
for every measured flower part. This conversion is also
straightforward with these other packages:

```{r}
ggplot()+
  theme_bw()+
  theme(panel.spacing=grid::unit(0, "lines"))+
  facet_grid(part ~ Species)+
  coord_equal()+
  geom_abline(slope=1, intercept=0, color="grey")+
  geom_point(aes(
    Length, Width),
    data=iris.dims$data)
```

However `stats::reshape` assumes that each input column name is
composed of (1) the output column name, (2) a delimiter, and (3) some
additional information to be stored in the output column given by
`timevar`. Therefore we need to pre-process column names for it to
work:

```{r}
```

It is clear from the comparisons above that each package is capable of
the conversions. However the syntax and level of explicitness varies:

* cdata requires explicit specification of a control table. (most
  explicit, most repetition)
* `tidyr::pivot_longer` and `stats::reshape` require specification of
  the input columns to melt along with a separator.
  * `stats::reshape` assumes the output columns names occur in the
    part of the input column name before the separator.
  * `tidyr::pivot_longer` assumes the output columns occur in the part
    which corresponds to the `.value` element of the `names_to`
    argument.
* `nc::capture_first_melt_multiple` requires a regular
  expression: (most implicit, least repetition)
  * any input column names that match the regex are melted.
  * values matched in the `column` group are used for the output column names.

### Two-step conversion: melt and then cast

Those four column names can be specified via a regex in
`nc::capture_first_melt`, which wraps `nc::capture_first_vec` and
`melt`:

```{r}
(iris.dt <- data.table(i=1:nrow(iris), iris[,1:4], Species=paste(iris$Species)))
(iris.tall <- nc::capture_first_melt(
  iris.dt,
  part=".*",
  "[.]",
  dim=".*"))
```

After the data have been converted to the tall table above, we can do a
`dcast` to get a data table which can help us visualize whether or not
sepals are bigger than petals:

```{r, fig.width=10}
(iris.part.cols <- dcast(
  iris.tall,
  i + Species + dim ~ part))
library(ggplot2)
ggplot()+
  theme_bw()+
  theme(panel.spacing=grid::unit(0, "lines"))+
  facet_grid(dim ~ Species)+
  coord_equal()+
  geom_abline(slope=1, intercept=0, color="grey")+
  geom_point(aes(
    Petal, Sepal),
    data=iris.part.cols)
 ```

It is clear from the plot above that sepals are indeed both longer and
wider than petals, on each measured plant.

Another data set where it is useful to do column name pattern matching
followed by melting is the World Health Organization data:

```{r}
data(who, package="tidyr")
names(who)
```

Each column which starts with `new` has three distinct pieces of
information encoded in its name: diagnosis type (e.g. sp or rel),
gender (m or f), and age range (e.g. 5564 or 1524). We would like to
use a regex to match these column names, then using the matching
columns as measure.vars in a melt, then join the two results. 

```{r}
new.diag.gender <- list(
  "new_?",
  diagnosis=".*",
  "_",
  gender=".")
nc::capture_first_melt(who, new.diag.gender, ages=".*")
```

Note the result includes additional columns `variable` and `value`
from `melt`. The `variable` column contains the input column names
which matched the specified pattern, and there is a new column for
each group in that pattern. The following example shows how to rename
the `variable` and `value` columns, specify `id.vars`, remove missing
values with `na.rm`, and use numeric type conversion functions:

```{r}
years.pattern <- list(new.diag.gender, ages=list(
  min.years="0|[0-9]{2}", as.numeric,
  max.years="[0-9]{0,2}", function(x)ifelse(x=="", Inf, as.numeric(x))))
(who.typed <- nc::capture_first_melt(
  who, years.pattern,
  value.name="count",
  variable.name="column",
  id.vars=c("iso2", "year"),
  na.rm=TRUE))
str(who.typed)
```

The result above shows that 

* non-character captured output columns can be obtained by specifying
  type conversion functions in the pattern.
* `id.vars`, `value.name`, `variable.name`, `na.rm` arguments are
  passed to `melt.data.table`.

## Comparison with tidyr

The `nc::capture_first_melt` function was inspired by the `tidyr`
package, which can accomplish the same computation via:

```{r}
tidyr::pivot_longer(
  who, new_sp_m014:newrel_f65,
  names_to=c("diagnosis", "gender", "ages"),
  names_pattern="new_?(.*)_(.)(.*)")
```

The syntax above is somewhat repetitive, since it requires specifying
columns to melt as the second argument, and it also requires
`names_pattern` which could be used to identify the columns to melt,
e.g.

```{r}
names.pattern <- "new_?(.*)_(.)(.*)"
tidyr::pivot_longer(
  who, grep(names.pattern, names(who)),
  names_to=c("diagnosis", "gender", "ages"),
  names_pattern=names.pattern)
```

To accomplish the type conversion using tidyr we need to do a
post-processing step, which requires additional repetition of the
column names we want to convert:

```{r}
(years.pattern.str <- nc::var_args_list(years.pattern)$pattern)
(tidyr.nona <- tidyr::pivot_longer(
  who,
  grep(years.pattern.str, names(who)),
  names_to=c("diagnosis", "gender", "ages", "ymin", "ymax"),
  values_drop_na=TRUE,
  names_pattern=years.pattern.str))
tidyr.typed <- transform(
  tidyr.nona,
  min.years=as.numeric(ymin),
  max.years=ifelse(is.na(ymax), Inf, as.numeric(ymax)))
str(tidyr.typed)
```

In conclusion `nc::capture_first_melt` provides an alternative which
(1) makes it easier to define complex patterns (2) supports type
conversion without a post-processing step, and (3) reduces repetition
in user code.

## Melting columns of different types into multiple result columns

In the previous sections we discussed methods for melting wide data
columns that all have the same type. Sometimes wide data have columns
of different types that we want to melt. The example below is taken
from a data.table vignette,

```{r}
family.dt <- fread(text="
family_id age_mother dob_child1 dob_child2 dob_child3 gender_child1 gender_child2 gender_child3
1         30 1998-11-26 2000-01-29         NA             1             2            NA
2         27 1996-06-22         NA         NA             2            NA            NA
3         26 2002-07-11 2004-04-05 2007-09-02             2             2             1
4         32 2004-10-10 2009-08-27 2012-07-21             1             1             1
5         29 2000-12-05 2005-02-28         NA             2             1            NA")
```

The data table above has one row for each family, and two columns for
each child. One column is the date of birth (character), the other is
the gender (coded as an integer). We can use standard data.table
functions to melt these data into a tall table with one row for each
child:

```{r}
melt(family.dt, variable.name="child", measure.vars=patterns(
  dob="^dob", gender="^gender"
))
```

The melt above results in a table with one row for each child, and one
column for each argument of `patterns`. However the code is somewhat
repetitive, as `dob` and `gender` must be repeated. To avoid this
repetition we can instead use:

```{r}
(children.dt <- nc::capture_first_melt_multiple(
  family.dt,
  column=".*",
  "_",
  nc::field("child", "", "[1-3]", as.integer),
  na.rm=TRUE))
str(children.dt)
```

The result above is similar to the previous result (and in fact
`melt.data.table` is used internally), but the code is less
repetitive. The first argument of `capture_first_melt_multiple` is the
subject data table and the following arguments form a pattern which is
matched to the input data column names. The pattern must have at least
two groups:

* One group must be named `column`. This group is used to capture the
  part of the input column names which will be used for the output
  column names. The output will contain one column for each unique
  value captured in this group.
* One or more other groups (with any names) specify an identifier for
  each observation (above it was the `child` number).

Another example is the iris data set which usually has one
5-dimensional observation per row (four numeric measures, and one
character `Species`). Below we create a shuffled version of the iris
data with two observations per row:

```{r}
set.seed(1)
iris.rand <- iris.dt[sample(.N)]
iris.wide <- cbind(treatment=iris.rand[1:75], control=iris.rand[76:150])
print(iris.wide, topn=2, nrows=10)
```

Below we show the usual data.table syntax for getting the original
iris back.

```{r}
iris.melted <- melt(iris.wide, measure.vars = patterns(
  i="i$",
  Sepal.Length="Sepal.Length$",
  Sepal.Width="Sepal.Width$",
  Petal.Length="Petal.Length$",
  Petal.Width="Petal.Width$",
  Species="Species$"))
identical(iris.melted[order(i), names(iris.dt), with=FALSE], iris.dt)
```

We can do the same thing with less repetition via:

```{r}
(nc.melted <- nc::capture_first_melt_multiple(
  iris.wide,
  group=".*?",
  "[.]",
  column=".*"))
identical(nc.melted[order(i), names(iris.dt), with=FALSE], iris.dt)
```

To conclude this section, we have seen that a simple non-repetitive
regex syntax can be used with `nc::capture_first_melt_multiple` to
melt wide data into several columns of different types.

## Comparison with tidyr syntax

The syntax below can be used to get the tall data table of children:

```{r}
tidyr::pivot_longer(
  family.dt,
  cols=dob_child1:gender_child3,
  names_pattern="(.*)_child([1-3])",
  names_to=c(".value", "child.str"),
  values_drop_na=TRUE)
```

However the code is somewhat repetitive, as the columns to melt must
be specified in two arguments: `cols` and `names_pattern`. A
workaround is to use a pre-defined pattern for both arguments:

```{r}
child.pat.str <- "(.*)_child([1-3])"
tidyr.children <- tidyr::pivot_longer(
  family.dt,
  cols=grep(child.pat.str, names(family.dt)),
  names_pattern=child.pat.str,
  names_to=c(".value", "child.str"),
  values_drop_na=TRUE)
(tidyr.converted <- transform(
  tidyr.children,
  child=as.integer(child.str)))
str(tidyr.converted)
```

However there is still some repetition: `child` appears in both the
pattern string and the `names_to` argument. That repetition is avoided
if `nc::capture_first_melt_multiple` is used with `nc::field`.

Another difference is that `nc` allows specification of type
conversion functions in the pattern, which results in an integer
`child` column. In contrast with `tidyr` output columns such as
`child.str` which are created using a regex capture group are always
character, so type conversions must be specified as a post-processing
step.

To conclude this section, we have seen that `tidyr::pivot_longer` uses
a different syntax to perform a similar computation to
`nc::capture_first_melt_multiple`. Two differences are that `nc`
syntax is less repetitive, and allows specifying type conversion
functions in the pattern, which avoids the need for a post-processing
step.
