<!--
%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{vignette 4: comparisons with other packages}
-->

# Comparisons with other packages

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This vignette provides comparisons with other packages that provide
similar functionality. We begin
by defining a helper function which ensures that results are the same:

```{r}
compare <- function(..., exclude="variable"){
  mc <- match.call()
  default.names <- paste(lapply(mc[-1], "[[", 1))
  L <- list(...)
  to.rep <- if(is.null(names(L)))rep(TRUE, length(L)) else names(L)==""
  names(L)[to.rep] <- default.names[to.rep]
  sorted.list <- list()
  all.name.vec <- names(L[[1]])
  name.vec <- all.name.vec[!all.name.vec %in% exclude]
  for(fun.name in names(L)){
    result <- data.table(L[[fun.name]])
    if(!all(name.vec %in% names(result))){
      print(result)
      stop("result needs names: ", paste(name.vec, collapse=", "))
    }
    sorted <- result[, name.vec, with=FALSE]
    setkeyv(sorted, name.vec)
    sorted.list[[fun.name]] <- sorted
  }
  ref.dt <- sorted.list[[1]]
  others <- sorted.list[-1]
  for(fun.name in names(others)){
    other.dt <- others[[fun.name]]
    all.eq <- all.equal(other.dt, ref.dt)
    if(!isTRUE(all.eq)){
      cat(fun.name, "\n", all.eq, "\n\n", sep="")
    }
  }
  L
}
```

Note that the function above returns a list of data frames, and checks
that each element in the list is equal to the first element.

## Are sepals larger or smaller than petals in the iris data?

Sometimes you want to melt a "wide" data table which has several
distinct pieces of information encoded in each column name. One
example is the familiar iris data, which have flower part and
measurement dimension encoded in each of four column names:

```{r}
library(data.table)
data.table(iris)
```

The goal in this section will be to convert these data into a format
with a column for each flower part (`Sepal` and `Petal`) so we can
easily make a facetted scatterplot to visually examine whether or not
sepals or larger than petals. The easiest way to perform this
conversion is with packages which provide a function for melting into
multiple output columns:

```{r}
iris.parts <- compare(
  nc::capture_first_melt_multiple(
    iris,
    column=".*?",
    "[.]",
    dim=".*"),
  tidyr::pivot_longer(
    iris, 
    cols=1:4, 
    names_to=c(".value", "dim"),
    names_sep="[.]"),
  stats::reshape(
    iris,
    direction="long",
    timevar="dim",
    varying=1:4,
    sep="."),
  "data.table::melt"=melt(
    data.table(iris),
    measure.vars=patterns(
      Sepal="^Sepal",
      Petal="^Petal")
  )[data.table(
    variable=factor(1:2), dim=c("Length", "Width")
  ), on=.(variable)],
  cdata::rowrecs_to_blocks(
    iris,
    controlTable=data.frame(
      dim=c("Length", "Width"),
      Petal=c("Petal.Length", "Petal.Width"),
      Sepal=c("Sepal.Length", "Sepal.Width"),
      stringsAsFactors=FALSE),
    columnsToCopy="Species"))
iris.parts$nc
```

It is clear from the code above that each package is capable of
the conversions. However the syntax and level of explicitness varies:

* `nc::capture_first_melt_multiple` requires a regular
  expression: (most implicit, least repetition)
  * any input column names that match the regex are melted.
  * values matched in the `column` group are used for the output column names.
* `tidyr::pivot_longer` and `stats::reshape` require specification of
  the input columns to melt along with a separator.
  * `stats::reshape` assumes the output columns names occur in the
    part of the input column name before the separator.
  * `tidyr::pivot_longer` assumes the output columns occur in the part
    which corresponds to the `.value` element of the `names_to`
    argument.
* `data.table::melt` requires a join to recover the `dim` output
  column.
* `cdata::rowrecs_to_blocks` requires explicit specification of a
  control table. (most explicit, most repetition)

Any of the results can be visualized via:

```{r}
library(ggplot2)
ggplot()+
  theme_bw()+
  theme(panel.spacing=grid::unit(0, "lines"))+
  facet_grid(dim ~ Species)+
  coord_equal()+
  geom_abline(slope=1, intercept=0, color="grey")+
  geom_point(aes(
    Petal, Sepal),
    data=iris.parts$nc)
```

It is clear from the plot above that sepals are larger than petals,
for every measured flower. 

## Comparing dimensions in iris data

What if we wanted to compare dimensions rather than parts? 

```{r}
iris.dims <- compare(
  nc::capture_first_melt_multiple(
    iris,
    part=".*?",
    "[.]",
    column=".*"),
  tidyr::pivot_longer(
    iris, 
    cols=1:4, 
    names_to=c("part", ".value"),
    names_sep="[.]"),
  stats::reshape(
    structure(iris, names=sub("(.*?)[.](.*)", "\\2.\\1", names(iris))),
    direction="long",
    timevar="part",
    varying=1:4,
    sep="."),
  "data.table::melt"=melt(
    data.table(iris),
    measure.vars=patterns(
      Length="Length$",
      Width="Width$")
  )[data.table(
    variable=factor(1:2), part=c("Sepal", "Petal")
  ), on=.(variable)],
  cdata::rowrecs_to_blocks(
    iris,
    controlTable=data.frame(
      part=c("Petal", "Sepal"),
      Length=c("Petal.Length", "Sepal.Length"),
      Width=c("Petal.Width", "Sepal.Width"),
      stringsAsFactors=FALSE),
    columnsToCopy="Species"))
iris.dims$nc
```

The code above shows that the syntax is mostly the same for this
example. The biggest difference is for `stats::reshape` which assumes
that each input column name is composed of (1) the output column name,
(2) a delimiter, and (3) some additional information to be stored in
the output column given by `timevar`. Therefore we need to pre-process
column names using `sub` for it to work.

```{r}
ggplot()+
  theme_bw()+
  theme(panel.spacing=grid::unit(0, "lines"))+
  facet_grid(part ~ Species)+
  coord_equal()+
  geom_abline(slope=1, intercept=0, color="grey")+
  geom_point(aes(
    Length, Width),
    data=iris.dims$data)
```

It is clear from the plot above that `Length` is larger than `Width`
for every measured flower part. This conversion is also
straightforward with these other packages:

## Melting into a single output column, character types

Another data set where it is useful to do column name pattern matching
followed by melting is the World Health Organization data:

```{r}
data(who, package="tidyr")
names(who)
```

Each column which starts with `new` has three distinct pieces of
information encoded in its name: diagnosis type (e.g. sp or rel),
gender (m or f), and age range (e.g. 5564 or 1524). We would like to
use a regex to match these column names, then using the matching
columns as measure.vars in a melt, then join the two results. The most
convenient way to do that is via:

```{r}
compare(
  nc::capture_first_melt(
    who,
    "new_?",
    diagnosis=".*",
    "_",
    gender=".",
    ages=".*"),
  tidyr::pivot_longer(
    who,
    new_sp_m014:newrel_f65,
    names_to=c("diagnosis", "gender", "ages"),
    names_pattern="new_?(.*)_(.)(.*)"))
```

Note the result includes additional columns `variable` and `value`
from `melt`. The `variable` column contains the input column names
which matched the specified pattern, and there is a new column for
each group in that pattern. The following example shows how to rename
the `variable` and `value` columns, remove missing
values with `na.rm`, and use numeric type conversion functions:

```{r}
library(dplyr)
who.typed <- compare(
  nc::capture_first_melt(
    who,
    "new_?",
    diagnosis=".*",
    "_",
    gender=".",
    ages=list(
      ymin.num="0|[0-9]{2}", as.numeric,
      ymax.num="[0-9]{0,2}", function(y)ifelse(y=="", Inf, as.numeric(y))),
    value.name="count",
    na.rm=TRUE),
  tidyr::pivot_longer(
    who,
    new_sp_m014:newrel_f65,
    names_to=c("diagnosis", "gender", "ages", "ymin.chr", "ymax.chr"),
    names_pattern="new_?(.*)_(.)((0|[0-9]{2})([0-9]{0,2}))",
    values_drop_na=TRUE,
    values_to="count"
   ) %>% dplyr::mutate(
    ymin.num=as.numeric(ymin.chr),
    ymax.num=ifelse(ymax.chr=="", Inf, as.numeric(ymax.chr))))
str(who.typed)  
```

The result above shows that `nc::capture_first_melt` (1) makes it
easier to define complex patterns (2) supports type conversion without
a post-processing step, and (3) reduces repetition in user code. 

Other packages for doing this include:

```{r}
who.pattern <- "new_?(.*)_(.)((0|[0-9]{2})([0-9]{0,2}))"
system.time({
  gather.result <- tidyr::gather(
    who,
    "variable",
    "count",
    grep(who.pattern, names(who)),
    na.rm=TRUE)
})
tidyr::extract(
  gather.result,
  "variable",
  c("diagnosis", "gender", "ages", "ymin.int", "ymax.int"),
  who.pattern,
  convert=TRUE
) %>% dplyr::mutate(
  ymin.num=as.numeric(ymin.int),
  ymax.num=ifelse(is.na(ymax.int), Inf, as.numeric(ymax.int)))
```

Note that gather requires two post-processing steps to achieve the same output as `nc`:

* `tidyr::extract` uses a regex to convert the melted column into
  several output columns; this results in repetition in the code
  because the regex is also used to define the columns to melt/gather.
* `dplyr::mutate` is used for converting age range variables to
  numeric, since default types are int with `convert=TRUE`.
  
```{r}
system.time({
  reshape2.result <- reshape2:::melt.data.frame(
    who,
    measure.vars=grep(who.pattern, names(who)),
    na.rm=TRUE,
    value.name="count")
})
```

```{r}
system.time({
  dt.result <- data.table::melt.data.table(
    data.table(who),
    measure.vars=grep(who.pattern, names(who)),
    na.rm=TRUE,
    value.name="count")
})
```

Neither cdata nor stats provide an na.rm option:

```{r}
who.df <- data.frame(who)
is.varying <- grepl(who.pattern, names(who))
names(who.df)[is.varying] <- paste0("count.", names(who)[is.varying])
system.time({
  stats.result <- stats::reshape(
    who.df,
    direction="long",
    timevar="variable",
    varying=is.varying)
})    
```

```{r}
system.time({
  cdata.result <- cdata::rowrecs_to_blocks(
    who, 
    cdata::build_unpivot_control(
      "variable",
      "count",
      grep(who.pattern, names(who), value=TRUE)),
    columnsToCopy=grep(who.pattern, names(who), value=TRUE, invert=TRUE))
})
```

