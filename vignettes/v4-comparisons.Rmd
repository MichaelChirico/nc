<!--
%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{vignette 4: comparisons with other packages}
-->

# Comparisons with other packages

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This vignette provides comparisons with other packages that provide
similar functionality. We begin
by defining a helper function which ensures that results are the same:

```{r}
compare <- function(..., exclude="variable"){
  mc <- match.call()
  default.names <- paste(lapply(mc[-1], "[[", 1))
  L <- list(...)
  to.rep <- if(is.null(names(L)))rep(TRUE, length(L)) else names(L)==""
  names(L)[to.rep] <- default.names[to.rep]
  sorted.list <- list()
  all.name.vec <- names(L[[1]])
  name.vec <- all.name.vec[!all.name.vec %in% exclude]
  for(fun.name in names(L[-1])){
    result.dt <- data.table(L[[fun.name]])
    if(0 < nrow(result.dt)){
      if(!all(name.vec %in% names(result.dt))){
        print(result.dt)
        stop(fun.name, " result needs names: ", paste(name.vec, collapse=", "))
      }
      sorted <- result.dt[, name.vec, with=FALSE]
      setkeyv(sorted, name.vec)
      sorted.list[[fun.name]] <- sorted
    }
  }
  ref.dt <- sorted.list[[1]]
  others <- sorted.list[-1]
  for(fun.name in names(others)){
    other.dt <- others[[fun.name]]
    all.eq <- all.equal(other.dt, ref.dt)
    if(!isTRUE(all.eq)){
      cat(fun.name, "\n", all.eq, "\n\n", sep="")
    }
  }
  L
}
```

Note that the function above returns a list of data frames, and checks
that each element in the list is equal to the first element.

## Are sepals larger or smaller than petals in the iris data?

Sometimes you want to melt a "wide" data table which has several
distinct pieces of information encoded in each column name. One
example is the familiar iris data, which have flower part and
measurement dimension encoded in each of four column names:

```{r}
library(data.table)
data.table(iris)
```

The goal in this section will be to convert these data into a format
with a column for each flower part (`Sepal` and `Petal`) so we can
easily make a facetted scatterplot to visually examine whether or not
sepals or larger than petals. The easiest way to perform this
conversion is with packages which provide a function for melting into
multiple output columns:

```{r}
iris.parts <- compare(
  nc::capture_first_melt_multiple(
    iris,
    column=".*?",
    "[.]",
    dim=".*"),
  tidyr::pivot_longer(
    iris, 
    cols=1:4, 
    names_to=c(".value", "dim"),
    names_sep="[.]"),
  stats::reshape(
    iris,
    direction="long",
    timevar="dim",
    varying=1:4,
    sep="."),
  "data.table::melt"=melt(
    data.table(iris),
    measure.vars=patterns(
      Sepal="^Sepal",
      Petal="^Petal")
  )[data.table(
    variable=factor(1:2), dim=c("Length", "Width")
  ), on=.(variable)],
  if(requireNamespace("cdata"))cdata::rowrecs_to_blocks(
    iris,
    controlTable=data.frame(
      dim=c("Length", "Width"),
      Petal=c("Petal.Length", "Petal.Width"),
      Sepal=c("Sepal.Length", "Sepal.Width"),
      stringsAsFactors=FALSE),
    columnsToCopy="Species"))
iris.parts$nc
```

It is clear from the code above that each package is capable of
the conversions. However the syntax and level of explicitness varies:

* `nc::capture_first_melt_multiple` requires a regular
  expression: (most implicit, least repetition)
  * any input column names that match the regex are melted.
  * values matched in the `column` group are used for the output column names.
* `tidyr::pivot_longer` and `stats::reshape` require specification of
  the input columns to melt along with a separator.
  * `stats::reshape` assumes the output columns names occur in the
    part of the input column name before the separator.
  * `tidyr::pivot_longer` assumes the output columns occur in the part
    which corresponds to the `.value` element of the `names_to`
    argument.
* `data.table::melt` requires a join to recover the `dim` output
  column.
* `cdata::rowrecs_to_blocks` requires explicit specification of a
  control table. (most explicit, most repetition)

Any of the results can be visualized via:

```{r}
library(ggplot2)
ggplot()+
  theme_bw()+
  theme(panel.spacing=grid::unit(0, "lines"))+
  facet_grid(dim ~ Species)+
  coord_equal()+
  geom_abline(slope=1, intercept=0, color="grey")+
  geom_point(aes(
    Petal, Sepal),
    data=iris.parts$nc)
```

It is clear from the plot above that sepals are larger than petals,
for every measured flower. 

## Comparing dimensions in iris data

What if we wanted to compare dimensions rather than parts? 

```{r}
iris.dims <- compare(
  nc::capture_first_melt_multiple(
    iris,
    part=".*?",
    "[.]",
    column=".*"),
  tidyr::pivot_longer(
    iris, 
    cols=1:4, 
    names_to=c("part", ".value"),
    names_sep="[.]"),
  stats::reshape(
    structure(iris, names=sub("(.*?)[.](.*)", "\\2.\\1", names(iris))),
    direction="long",
    timevar="part",
    varying=1:4,
    sep="."),
  "data.table::melt"=melt(
    data.table(iris),
    measure.vars=patterns(
      Length="Length$",
      Width="Width$")
  )[data.table(
    variable=factor(1:2), part=c("Sepal", "Petal")
  ), on=.(variable)],
  if(requireNamespace("cdata"))cdata::rowrecs_to_blocks(
    iris,
    controlTable=data.frame(
      part=c("Petal", "Sepal"),
      Length=c("Petal.Length", "Sepal.Length"),
      Width=c("Petal.Width", "Sepal.Width"),
      stringsAsFactors=FALSE),
    columnsToCopy="Species"))
iris.dims$nc
```

The code above shows that the syntax is mostly the same for this
example. The biggest difference is for `stats::reshape` which assumes
that each input column name is composed of (1) the output column name,
(2) a delimiter, and (3) some additional information to be stored in
the output column given by `timevar`. Therefore we need to pre-process
column names using `sub` for it to work.

```{r}
ggplot()+
  theme_bw()+
  theme(panel.spacing=grid::unit(0, "lines"))+
  facet_grid(part ~ Species)+
  coord_equal()+
  geom_abline(slope=1, intercept=0, color="grey")+
  geom_point(aes(
    Length, Width),
    data=iris.dims$data)
```

It is clear from the plot above that `Length` is larger than `Width`
for every measured flower part. This conversion is also
straightforward with these other packages:

## Melting into a single output column, character types

Another data set where it is useful to do column name pattern matching
followed by melting is the World Health Organization data:

```{r}
data(who, package="tidyr")
names(who)
```

Each column which starts with `new` has three distinct pieces of
information encoded in its name: diagnosis type (e.g. sp or rel),
gender (m or f), and age range (e.g. 5564 or 1524). We would like to
use a regex to match these column names, then using the matching
columns as measure.vars in a melt, then join the two results. The most
convenient way to do that is via:

```{r}
compare(
  nc::capture_first_melt(
    who,
    "new_?",
    diagnosis=".*",
    "_",
    gender=".",
    ages=".*"),
  tidyr::pivot_longer(
    who,
    new_sp_m014:newrel_f65,
    names_to=c("diagnosis", "gender", "ages"),
    names_pattern="new_?(.*)_(.)(.*)"))
```

Note the result includes additional columns `variable` and `value`
from `melt`. The `variable` column contains the input column names
which matched the specified pattern, and there is a new column for
each group in that pattern. The following example shows how to rename
the `variable` and `value` columns, remove missing
values with `na.rm`, and use numeric type conversion functions:

```{r}
library(dplyr)
who.typed <- compare(
  nc::capture_first_melt(
    who,
    "new_?",
    diagnosis=".*",
    "_",
    gender=".",
    ages=list(
      ymin.num="0|[0-9]{2}", as.numeric,
      ymax.num="[0-9]{0,2}", function(y)ifelse(y=="", Inf, as.numeric(y))),
    value.name="count",
    na.rm=TRUE),
  tidyr::pivot_longer(
    who,
    new_sp_m014:newrel_f65,
    names_ptypes=list(ymin.num=numeric()),
    names_to=c("diagnosis", "gender", "ages", "ymin.num", "ymax.chr"),
    names_pattern="new_?(.*)_(.)((0|[0-9]{2})([0-9]{0,2}))",
    values_drop_na=TRUE,
    values_to="count"
   ) %>% dplyr::mutate(
    ymax.num=ifelse(ymax.chr=="", Inf, as.numeric(ymax.chr))))
str(who.typed)  
```

The result above shows that `nc::capture_first_melt` (1) makes it
easier to define complex patterns (2) supports type conversion without
a post-processing step, and (3) reduces repetition in user code. 

Other packages for doing this include:

```{r}
who.pattern <- "new_?(.*)_(.)((0|[0-9]{2})([0-9]{0,2}))"
system.time({
  gather.result <- tidyr::gather(
    who,
    "variable",
    "count",
    grep(who.pattern, names(who)),
    na.rm=TRUE)
})
tidyr::extract(
  gather.result,
  "variable",
  c("diagnosis", "gender", "ages", "ymin.int", "ymax.int"),
  who.pattern,
  convert=TRUE
) %>% dplyr::mutate(
  ymin.num=as.numeric(ymin.int),
  ymax.num=ifelse(is.na(ymax.int), Inf, as.numeric(ymax.int)))
```

Note that gather requires two post-processing steps to achieve the same output as `nc`:

* `tidyr::extract` uses a regex to convert the melted column into
  several output columns; this results in repetition in the code
  because the regex is also used to define the columns to melt/gather.
* `dplyr::mutate` is used for converting age range variables to
  numeric, since default types are int with `convert=TRUE`.
  
```{r}
system.time({
  reshape2.result <- reshape2:::melt.data.frame(
    who,
    measure.vars=grep(who.pattern, names(who)),
    na.rm=TRUE,
    value.name="count")
})
```

```{r}
system.time({
  dt.result <- data.table::melt.data.table(
    data.table(who),
    measure.vars=grep(who.pattern, names(who)),
    na.rm=TRUE,
    value.name="count")
})
```

Neither cdata nor stats provide an na.rm option:

```{r}
who.df <- data.frame(who)
is.varying <- grepl(who.pattern, names(who))
names(who.df)[is.varying] <- paste0("count.", names(who)[is.varying])
system.time({
  stats.result <- stats::reshape(
    who.df,
    direction="long",
    timevar="variable",
    varying=is.varying)
})    
```

```{r}
if(requireNamespace("cdata")){
system.time({
  cdata.result <- cdata::rowrecs_to_blocks(
    who, 
    cdata::build_unpivot_control(
      "variable",
      "count",
      grep(who.pattern, names(who), value=TRUE)),
    columnsToCopy=grep(who.pattern, names(who), value=TRUE, invert=TRUE))
})
}
```

## Melting a wider iris back to original

```{r}
## Example 1: melting a wider iris data back to original.
library(data.table)
iris.dt <- data.table(
  i=1:nrow(iris),
  iris[,1:4],
  Species=paste(iris$Species))
print(iris.dt)

## what if we had two observations on each row?
set.seed(1)
iris.rand <- iris.dt[sample(.N)]
iris.wide <- cbind(treatment=iris.rand[1:75], control=iris.rand[76:150])
print(iris.wide, topn=2, nrows=10)

## This is the usual data.table syntax for getting the original iris back.
iris.melted <- melt(iris.wide, value.factor=TRUE, measure.vars = patterns(
  i="i$",
  Sepal.Length="Sepal.Length$",
  Sepal.Width="Sepal.Width$",
  Petal.Length="Petal.Length$",
  Petal.Width="Petal.Width$",
  Species="Species$"))
identical(iris.melted[order(i), names(iris.dt), with=FALSE], iris.dt)

## nc can do the same thing -- you must define an R argument named
## column, and another named argument which identifies each group.
(nc.melted <- nc::capture_first_melt_multiple(
  iris.wide,
  group="[^.]+",
  "[.]",
  column=".*"))
identical(nc.melted[order(i), names(iris.dt), with=FALSE], iris.dt)

## This is how we do it using stats::reshape.
iris.wide.df <- data.frame(iris.wide)
names(iris.wide.df) <- sub("(.*?)[.](.*)", "\\2_\\1", names(iris.wide))
iris.reshaped <- stats::reshape(
  iris.wide.df,
  direction="long",
  timevar="group",
  varying=names(iris.wide.df),
  sep="_")
identical(data.table(iris.reshaped[, names(iris.dt)])[order(i)], iris.dt)

## get the parts columns and groups -- is there any difference
## between groups? of course not!
parts.wide <- nc::capture_first_melt_multiple(
  iris.wide,
  group=".*?",
  "[.]",
  column=".*?",
  "[.]",
  dim=".*")
if(require("ggplot2")){
  ggplot()+
    theme_bw()+
    theme(panel.spacing=grid::unit(0, "lines"))+
    facet_grid(dim ~ group)+
    coord_equal()+
    geom_abline(slope=1, intercept=0, color="grey")+
    geom_point(aes(
      Petal, Sepal),
      data=parts.wide)
}


```

## Lots of column types

```{r}
## Example 2. Lots of column types, from example(melt.data.table).
DT <- data.table(
  i_1 = c(1:5, NA),
  i_2 = c(NA,6:10),
  f_1 = factor(sample(c(letters[1:3], NA), 6, TRUE)),
  f_2 = factor(c("z", "a", "x", "c", "x", "x"), ordered=TRUE),
  c_1 = sample(c(letters[1:3], NA), 6, TRUE),
  d_1 = as.Date(c(1:3,NA,4:5), origin="2013-09-01"),
  d_2 = as.Date(6:1, origin="2012-01-01"))
## add a couple of list cols
DT[, l_1 := DT[, list(c=list(rep(i_1, sample(5,1)))), by = i_1]$c]
DT[, l_2 := DT[, list(c=list(rep(c_1, sample(5,1)))), by = i_1]$c]

## original DT syntax is quite repetitive.
melt(DT, measure=patterns(
  i="^i",
  f="^f",
  d="^d",
  l="^l"
))

## nc syntax uses a single regex rather than four.
nc::capture_first_melt_multiple(
  DT,
  column="^[^c]",
  "_",
  number="[12]")

## id.vars can be specified using original DT syntax.
melt(DT, id=1:2, measure=patterns(
  f="^f",
  l="^l"
))

## id.vars can also be specified using nc syntax.
nc::capture_first_melt_multiple(
  DT,
  column="^[fl]",
  "_",
  number="[12]",
  id.vars=1:2)

## reshape does not support list columns.
reshape(
  DT,
  varying=grep("^[fid]", names(DT)),
  sep="_",
  direction="long",
  timevar="number")

## tidyr does, but errors for combining ordered and un-ordered factors.
tidyr::pivot_longer(DT, grep("[cf]", names(DT), invert=TRUE), names_pattern="(.)_(.)", names_to=c(".value", "number"))

```

## family data

```{r}
  ## Example 3, three children, one family per row, from data.table
  ## vignette.
  family.dt <- fread(text="
family_id age_mother dob_child1 dob_child2 dob_child3 gender_child1 gender_child2 gender_child3
1         30 1998-11-26 2000-01-29         NA             1             2            NA
2         27 1996-06-22         NA         NA             2            NA            NA
3         26 2002-07-11 2004-04-05 2007-09-02             2             2             1
4         32 2004-10-10 2009-08-27 2012-07-21             1             1             1
5         29 2000-12-05 2005-02-28         NA             2             1            NA")
  (children.melt <- melt(family.dt, measure = patterns(
    dob="^dob", gender="^gender"
  ), variable.name="child", na.rm=TRUE, variable.factor=FALSE))
  
  ## nc::field can be used to define group name and pattern at the
  ## same time, to avoid repetitive code.
  (children.nc <- nc::capture_first_melt_multiple(
     family.dt,
     column="[^_]+",
     "_",
     nc::field("child", "", "[1-3]"),
     na.rm=TRUE))
  identical(children.nc[, names(children.melt), with=FALSE], children.melt)
  
  ## reshape works too.
  reshape(
    family.dt,
    varying=grep("child", names(family.dt)),
    direction="long",
    sep="_",
    timevar="child.str")
  
```
