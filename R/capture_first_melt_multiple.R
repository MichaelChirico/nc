capture_first_melt_multiple <- structure(function # Capture and melt multiple columns of different types
### Extract first match of a regex from data.frame column names, by
### calling capture_first_vec on column names. Each unique value
### captured in the group named "column" will become a column name
### in the result; this syntax can be less repetitive than using
### data.table::patterns.
(subject.df,
### The data.frame with column name subjects.
  ...,
### Pattern passed to capture_first_vec. There must be an argument
### named "column" and at least one other named argument.
  id.vars=NULL,
### columns to use as id.vars in data.table::melt.data.table. Default
### NULL means to use all variables not matched by the pattern.
  na.rm=FALSE,
### remove missing values from melted data? (passed to
### data.table::melt.data.table)
  verbose=getOption("datatable.verbose")
### Print verbose output messages? (passed to
### data.table::melt.data.table)
){
  column <- variable <- . <- count <- .col.i <- ..by.vec <- NULL
  ## Above to avoid CRAN NOTE.
  if(!is.data.frame(subject.df)){
    stop("subject must be a data.frame")
  }
  match.dt <- capture_first_vec(
    names(subject.df),
    ...,
    nomatch.error=FALSE)
  if(is.null(match.dt$column)){
    stop("pattern must define group named column")
  }
  no.match <- apply(is.na(match.dt), 1, all)
  if(all(no.match)){
    stop(
      "no column names match regex below\n",
      var_args_list(...)$pattern)
  }
  not.col <- names(match.dt)[names(match.dt) != "column"]
  if(length(not.col)==0){
    stop("need at least one group other than column")
  }
  dot.names <- grep("^[.]", names(match.dt), value=TRUE)
  if(length(dot.names)){
    stop(
      "dot (.) must not be used ",
      "at the start of an argument/group name, ",
      "problems: ",
      paste(dot.names, collapse=", "))
  }
  by.list <- list(
    group=not.col,
    column="column")
  by.result <- list()
  for(by.name in names(by.list)){
    by.vec <- by.list[[by.name]]
    by.counts <- match.dt[!is.na(column), .(count=.N), by=by.vec]
    by.max <- max(by.counts$count)
    by.prob <- by.counts[count != by.max]
    if(nrow(by.prob)){
      count.vec <- sprintf(
        "%s=%d",
        apply(by.counts[, ..by.vec], 1, paste, collapse=","),
        by.counts$count)
      stop(
        "need same number of values for each ", by.name,
        " but have: ", paste(count.vec, collapse=" "))
    }
    by.result[[by.name]] <- by.counts
  }
  if(nrow(by.result$column)==1){
    stop(
      "need multiple output columns, ",
      "but only one value (",
      by.result$column$column,
      ") captured in column group; ",
      "either provide a different regex ",
      "that captures more than one value in column group, ",
      "or use capture_first_melt ",
      "if you really want only one output column")
  }
  if(is.null(id.vars)){
    id.vars <- which(is.na(match.dt$column))
  }
  i.dt <- data.table(
    .col.i=1:nrow(match.dt),
    match.dt,
    key=c("column", not.col))#need to sort by not.col for irregular col ord.
  indices.dt <- i.dt[!is.na(column), list(indices=list(.col.i)), by=column]
  measure.vars <- with(indices.dt, structure(indices, names=column))
  ##seealso<< Internally we call data.table::melt.data.table with
  ##measure.vars=a named list generated by the regex.
  melted <- melt(
    data.table(subject.df),
    id.vars=id.vars,
    measure.vars=measure.vars,
    na.rm=na.rm,
    variable.factor=TRUE,#integer join on integer later.
    value.factor=FALSE,
    variable.name=".variable",
    verbose=verbose)
  ## Join on variable but remove it since we require the user to
  ## provide at least one other group which should be more
  ## informative/interpretable, which makes variable useless.
  group.var.dt <- by.result$group[, data.table(
    ".variable"=1:.N,
    .SD[, not.col, with=FALSE])]
  join.dt <- group.var.dt[melted, on=".variable"]
  join.dt[, names(join.dt) != ".variable", with=FALSE]
### Data table of melted/tall data, with a new column for each unique
### value of the capture group named "column".
}, ex=function(){
  
  ## Example 1: melting to multiple value columns.
  library(data.table)
  iris.dt <- data.table(
    i=1:nrow(iris),
    iris[,1:4],
    Species=paste(iris$Species))
  print(iris.dt)
  
  ## what if we had two observations on each row?
  set.seed(1)
  iris.rand <- iris.dt[sample(.N)]
  iris.wide <- cbind(treatment=iris.rand[1:75], control=iris.rand[76:150])
  print(iris.wide, topn=2, nrows=10)
  
  ## This is the usual data.table syntax for getting the original iris back.
  iris.melted <- melt(iris.wide, value.factor=TRUE, measure.vars = patterns(
    i="i$",
    Sepal.Length="Sepal.Length$",
    Sepal.Width="Sepal.Width$",
    Petal.Length="Petal.Length$",
    Petal.Width="Petal.Width$",
    Species="Species$"))
  identical(iris.melted[order(i), names(iris.dt), with=FALSE], iris.dt)
  
  ## nc can do the same thing -- you must define an R argument named
  ## variable, and another named argument which identifies each group.
  (nc.melted <- nc::capture_first_melt_multiple(
    iris.wide,
    group="[^.]+",
    "[.]",
    column=".*"))
  identical(nc.melted[order(i), names(iris.dt), with=FALSE], iris.dt)
  
  ## Example 2. Lots of column types, from example(melt.data.table).
  DT <- data.table(
    i_1 = c(1:5, NA),
    i_2 = c(NA,6:10),
    f_1 = factor(sample(c(letters[1:3], NA), 6, TRUE)),
    f_2 = factor(c("z", "a", "x", "c", "x", "x"), ordered=TRUE),
    c_1 = sample(c(letters[1:3], NA), 6, TRUE),
    d_1 = as.Date(c(1:3,NA,4:5), origin="2013-09-01"),
    d_2 = as.Date(6:1, origin="2012-01-01"))
  ## add a couple of list cols
  DT[, l_1 := DT[, list(c=list(rep(i_1, sample(5,1)))), by = i_1]$c]
  DT[, l_2 := DT[, list(c=list(rep(c_1, sample(5,1)))), by = i_1]$c]
  
  ## original DT syntax is quite repetitive.
  melt(DT, measure=patterns(
    i="^i",
    f="^f",
    d="^d",
    l="^l"
  ))
  
  ## nc syntax uses a single regex rather than four.
  nc::capture_first_melt_multiple(
    DT,
    column="^[^c]",
    "_",
    number="[12]")
  
  ## id.vars can be specified using original DT syntax.
  melt(DT, id=1:2, measure=patterns(
    f="^f",
    l="^l"
  ))
  
  ## id.vars can also be specified using nc syntax.
  nc::capture_first_melt_multiple(
    DT,
    column="^[fl]",
    "_",
    number="[12]",
    id.vars=1:2)
  
  ## Example 3, three children, one family per row, from data.table
  ## vignette.
  family.dt <- fread(text="
family_id age_mother dob_child1 dob_child2 dob_child3 gender_child1 gender_child2 gender_child3
1         30 1998-11-26 2000-01-29         NA             1             2            NA
2         27 1996-06-22         NA         NA             2            NA            NA
3         26 2002-07-11 2004-04-05 2007-09-02             2             2             1
4         32 2004-10-10 2009-08-27 2012-07-21             1             1             1
5         29 2000-12-05 2005-02-28         NA             2             1            NA")
  (children.melt <- melt(family.dt, measure = patterns(
    dob="^dob", gender="^gender"
  ), variable.name="child", na.rm=TRUE, variable.factor=FALSE))
  
  ## nc::field can be used to define group name and pattern at the
  ## same time, to avoid repetitive code.
  (children.nc <- nc::capture_first_melt_multiple(
    family.dt,
    column="[^_]+",
    "_",
    nc::field("child", "", "[1-3]"),
    na.rm=TRUE))
  identical(children.nc[, names(children.melt), with=FALSE], children.melt)
  
})


